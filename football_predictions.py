# -*- coding: utf-8 -*-
"""football predictions.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gRuiB2pJ6HFuew3P7N9M5a0KoOn5-pbm

# Predicting the value of players in FIFA 19 using KNN
---

# 1. Import and preview dataset
"""

import pandas as pd

# Specify the file path and encoding
file_path = 'last_ten_years_basketball data.csv'
encoding = 'latin1'  # or 'ISO-8859-1'

try:
    # Attempt to read the CSV file
    data = pd.read_csv(file_path, encoding=encoding)

    # Display the first few rows to verify
    print(data.head())

    # Further data processing or analysis can follow here

except UnicodeDecodeError as e:
    print(f"UnicodeDecodeError: {e}. Try specifying a different encoding.")
except Exception as e:
    print(f"Error: {e}")

#Check number of columns in dataframe
num_col = len(data.columns)
print("Number of columns in dataframe:",num_col)

#Unhide all columns and then preview first 5 rows of dataframe to indentify columns
pd.options.display.max_columns = num_col
data.head()

#Assign all columns to variable and then preview columns
stats_columns = data.columns
stats_columns

"""# 2. Data Cleaning

"""

# Assuming 'data' is your original dataframe
dropped_cols = [ 'Photo', 'Nationality', 'Flag', 'Club Logo', 'Real Face', 'Body Type']
data_updated = data.drop(dropped_cols, axis=1)

# Print preview of the updated dataframe
print(data_updated.head())

#Drop all rows of players with missing position information:
data_na_pos_removed = data_updated.dropna(subset = ['Position'])
# data_na_pos_removed
print("Rows in dataframe before removing missing position information:",len(data_updated))
print("Rows in dataframe after dropping rows with missing position information:",len(data_na_pos_removed))

#Function to check for missing information in any column:
def check_na_vals(dataframe):
    return dataframe[dataframe.isna().any(axis = 1)]

rows_with_na = check_na_vals(data_na_pos_removed)

#Function to use display options to show only 10 rows but also indicate number of rows below dataframe
def display_10_rows(dataframe):
    with pd.option_context('display.max_rows', 10):
            display(dataframe)

display_10_rows(rows_with_na)

#Remove Joined and Loaned columns
data_cols_removed = data_na_pos_removed.drop(['Joined','Loaned From'], axis = 1)

#Check for missing information in any other columns:
rows_with_na = check_na_vals(data_cols_removed)

#See first 10 rows of dataframe containing na values:
display_10_rows(rows_with_na)

#Remove rating-by-position columns
remove_cols = ['LS','ST','RS','LW','LF','CF','RF','RW','LAM','CAM','RAM','LM','LCM','CM',
                    'RCM','RM','LWB','LDM','CDM','RDM','RWB','LB','LCB','CB','RCB','RB']
data_positions_removed = data_cols_removed.drop(columns = remove_cols)

#Check for missing information in any other columns:
rows_with_na = check_na_vals(data_positions_removed)

#See first 10 rows of dataframe containing na values:
display_10_rows(rows_with_na)

#Fill null values in Release Caluse column with 0
data_release_filled = data_positions_removed.fillna({"Release Clause" : 0})

#Check for missing information in any other columns:
rows_with_na = check_na_vals(data_release_filled)

#See first 10 rows of dataframe containing na values:
display_10_rows(rows_with_na)

#Remove € character from "Values" column
data_release_filled['Value'] = data_release_filled['Value'].str.replace('?','')

#Remove K and M characters from "Values" column after multiplying to get correct order
data_release_filled['Value'] = data_release_filled['Value'].replace({'.5K':'500',
                                                                     'K':'000',
                                                                     '.5M':'500000',
                                                                     'M':'000000'},
                                                                    regex = True).map(pd.eval).astype(int)

# Remove rows with 0 in "Value" column
players_with_value = data_release_filled[data_release_filled['Value'] != 0]

#Check for null values in updated dataframe:
print("Number of rows containing null values:",players_with_value.isna().any(axis = 1).sum())

#Print number of rows in dataframe with data in 'Value' column and preview this dataframe
print("Number of rows in dataframe with no missing values",len(players_with_value))

players_with_value.head()

"""There are now no rows with missing information, so we can continue to select the appropriate data for the KNN algorithm"""

#Print statistics overview
players_with_value['Value'].describe().apply(lambda x: format(x, 'f'))

import matplotlib.pyplot as plt
import numpy as np

# Assuming players_with_value is your DataFrame containing player values

# Plot frequency of player value ranges in €5 million intervals
fig = plt.figure(figsize=(10, 7))
# Use 20 bins of player values. Value divided by 10^6 so x-axis units are in millions
(players_with_value['Value'] / 10**6).plot.hist(bins=20)
plt.ticklabel_format(style='plain', axis='x')
plt.xticks(np.arange(0, 125, 10))
plt.xlabel('Player values (€M)')
plt.show()

#Assign players with value > €5 million to new dataframe
above_5m = players_with_value[players_with_value['Value'] >= 5000000]

#Check no. players in new dataframe
print("Players with value above €5 000 000:" , len(above_5m))

#Plot frequency of player value ranges above €5 million
fig = plt.figure(figsize = (10,7))
#Use 20 bins of player values. Value divided by 10^6 so x-axis units are in millions
(above_5m['Value']/10**6).plot.hist(bins = 20)
plt.ticklabel_format(style = 'plain', axis = 'x')
plt.xticks(np.arange(0,125,10))
plt.xlabel('Player values (€M)')
plt.show()

"""# 3. Convert numerical inforamtion stored as strings to correct data format

"""

#Define list of attributes that will be used for training.
attributes = list(above_5m.columns)
remove_attributes = ['Name','Age','Club','Special','Preferred Foot']
attributes = [attr for attr in attributes if attr not in remove_attributes]

#Check datatype of every column to identify which contain string values
above_5m[attributes].dtypes

"""The 'Wage', 'Work Rate', 'Contract Valid Until', 'Height', 'Weight' and 'Release Clause' columns need to be either removed, cleaned and converted to text or be assigned numerical values based on the text data contained in the column. Lets have a look at the types of values in each of those columns to decide on how to proceed. Note the 'Position' column column also contains text data but this column will only be used to categorize players and not to predict their value."""

#Print some of the data contained in columns containing text
#to investigate how to convert these columns to integers
print("Unique values in text columns:")
print("Wage:", above_5m['Wage'][0:6])
print("Wage:", above_5m['Wage'].unique())
print("\nContract Valid Until:", above_5m['Contract Valid Until'].unique())
print("\nHeight:", above_5m['Height'].unique())
print("\nWeight:", above_5m['Weight'].unique())
print("\nRelease Clause:\n", above_5m['Release Clause'][0:5])

"""# 4. Assign numerical information to categorical data

"""

# #Assign numerical values to 'Work Rate' column
work_rate_cleanup = {'Low/ Low': (1+1)/2, 'Low/ Medium': (1+2)/2,'Medium/ Low':(2+1)/2,
                     'Low/ High':(1+3)/2,'High/ Low':(3+1)/2, 'Medium/ Medium': (2+2)/2,
                     'High/ Medium': (3+2)/2, 'Medium/ High': (2+3)/2, 'High/ High': (3+3)/2}

above_5m['Work Rate'].replace(work_rate_cleanup, inplace = True)

"""# 5. Normalization

"""

# List of columns that won't be normalized
non_data_cols = ['Player', 'Club', 'Position', 'Wage', 'Preferred Foot', 'Value']

# Identify columns to be normalized (numeric columns excluding non_data_cols)
normalized_attributes = [attr for attr in above_5m.columns if attr not in non_data_cols and above_5m[attr].dtype in [int, float]]

# Create DataFrame with only numeric columns for normalization
normalized_data = above_5m[normalized_attributes]

# Perform normalization
normalized_data = (normalized_data - normalized_data.min()) / (normalized_data.max() - normalized_data.min())
# Concatenate non-numeric columns back to the normalized DataFrame
normalized = pd.concat([above_5m[non_data_cols], normalized_data], axis=1)

# Preview the normalized DataFrame
print(normalized.head())

"""# 6. Categorize players into new dataframes according to position

"""

#Preview unique positions in dataframe in order to isolate according to each dataframe
positions = normalized['Position'].unique()
positions

#Lists of positions in each category
list_forwards = ['LS','ST','RS','LF','CF','RF']
list_midfielders = ['LAM','CAM','RAM','LW','RW','LM','LCM','CM','RCM','RM','LDM','CDM','RDM']
list_defenders = ['LWB','RWB','LB','LCB','RCB','RB']
list_goalkeepers = ['GK']

#Create new dataframes of players categorised according to position
forwards = normalized[normalized['Position'].isin(list_forwards)]
midfielders = normalized[normalized['Position'].isin(list_midfielders)]
defenders = normalized[normalized['Position'].isin(list_defenders)]
goalkeepers = normalized[normalized['Position'].isin(list_goalkeepers)]

print('Number of forwards:',len(forwards))
print('Number of midfielders:',len(midfielders))
print('Number of defenders:',len(defenders))
print('Number of goalkeepers:',len(goalkeepers))

"""# 7. Identify 10 most relevant attributes for predicting player value

## Function for K-Nearest Neighbours Algorithm
"""

from sklearn.neighbors import KNeighborsRegressor
from sklearn.metrics import mean_squared_error

#Define function for KNN. Target column does not need to be an argument since it
#is always going to be the 'Value' column
def KNN_uni(df, train_col):
    knn = KNeighborsRegressor()

    #Randomize dataframe
    random_index = np.random.permutation(df.index)
    random_df = df.reindex(random_index)

    #Train using training column sent to function
    knn.fit(df[[train_col]],df['Value'])

    #Predict using trained model
    predictions = knn.predict(df[[train_col]])

    #Calculate RMSE
    mse = mean_squared_error(df['Value'], predictions)
    rmse = np.sqrt(mse)

    return rmse

"""## Run univariate KNN for each attribute and each category of player

"""

import pandas as pd

# Example function for KNN_uni (replace with your actual implementation)
def KNN_uni(dataframe, attribute):
    # Replace with your actual implementation of KNN or RMSE calculation
    # Here, a dummy example is used
    return 0.0  # Replace with actual RMSE calculation

# Assuming normalized, forwards, midfielders, defenders, goalkeepers DataFrames are defined

# Adjusted get_RMSE function assuming a fixed number of neighbors
def get_RMSE(dataframe, train_attributes):
    RMSEs = {}
    for attribute in train_attributes:
        rmse = KNN_uni(dataframe, attribute)  # Assuming KNN_uni does not require n_neighbors
        RMSEs[attribute] = rmse

    # Sort RMSEs dictionary by RMSE values
    rmse_tuple = sorted(RMSEs.items(), key=lambda x: x[1])

    # Create DataFrame of top 10 attributes with lowest RMSE
    top_10 = pd.DataFrame(rmse_tuple[:10], columns=['Attribute', 'RMSE'])
    return top_10

# Assign all column names to attributes variable
attributes = list(normalized.columns)

# Remove unwanted but potentially useful data columns from attributes
remove_attributes = ['Name', 'Age', 'Value', 'Club', 'Special', 'Wage', 'Preferred Foot', 'Position']
train_attributes = [attr for attr in attributes if attr not in remove_attributes]

# Run get_RMSE function to get RMSE value for each category of player
top_10_forwards = get_RMSE(forwards, train_attributes)
top_10_midfielders = get_RMSE(midfielders, train_attributes)
top_10_defenders = get_RMSE(defenders, train_attributes)
top_10_goalkeepers = get_RMSE(goalkeepers, train_attributes)

# Display results or further processing as needed
print("Top 10 attributes for forwards:")
print(top_10_forwards)

print("\nTop 10 attributes for midfielders:")
print(top_10_midfielders)

print("\nTop 10 attributes for defenders:")
print(top_10_defenders)

print("\nTop 10 attributes for goalkeepers:")
print(top_10_goalkeepers)

#Check number of attributes that were used to train the model

print(len(train_attributes))

#Use display() function to display dataframes as tables
print("Top 10 predictors for forwards:")
display(top_10_forwards)
print("===============================")

print("\nTop 10 predictors for midfielders:")
display(top_10_midfielders)
print("===============================")

print("\nTop 10 predictors for defenders:")
display(top_10_defenders)
print("===============================")

print("\nTop 10 predictors for goalkeepers:")
display(top_10_goalkeepers)
print("===============================")

#Create list of top 10 attributes for each category from the relevant dataframes

fwd_predictors = top_10_forwards['Attribute'].tolist()
mid_predictors = top_10_midfielders['Attribute'].tolist()
def_predictors = top_10_defenders['Attribute'].tolist()
gk_predictors = top_10_goalkeepers['Attribute'].tolist()

"""# 8. Predict player value using KNN

"""

def knn_predict(dataframe, predictors):
    # Exclude non-numeric columns from predictors
    predictors = [col for col in predictors if dataframe[col].dtype in [np.float64, np.int64]]

    # Ensure at least 1 neighbor is used, assuming len(dataframe) > 1
    n_neighbors = min(len(dataframe) - 1, 3)
    if n_neighbors < 1:
        n_neighbors = 1  # Set minimum number of neighbors to 1 if dataframe is very small

    knn = KNeighborsRegressor(n_neighbors=n_neighbors)

    # Train using set of attributes sent to function
    knn.fit(dataframe[predictors], dataframe['Value'])

    # Run prediction of player value using set of attributes sent to function.
    # Add these predicted values as well as the error compared to the
    # true FIFA 19 value to a new dataframe
    predicted = dataframe[['Player', 'Value']].copy()
    predicted['Predicted'] = knn.predict(dataframe[predictors])
    predicted['% Difference'] = round(((predicted['Value'] - predicted['Predicted']) / predicted['Value']) * 100, 2)

    # Return predicted values sorted by % difference to FIFA 19 value
    return predicted.sort_values('% Difference', ascending=False)

"""# 9. Data Visualization

"""

import matplotlib.pyplot as plt
import pandas as pd

fig = plt.figure(figsize=(7, 20))

# Function to plot % Difference column for dataframe sent to function
def plot(dataframe, category, plot_pos):
    ax = fig.add_subplot(4, 1, plot_pos)
    ax.hist(dataframe['% Difference'])
    ax.set_xlabel('Difference between predicted price & FIFA 19 price (%)')
    ax.set_ylabel('Frequency')
    ax.set_title('Percentage difference in predicted price for ' + category)
    fig.tight_layout()

# Assuming fwd_prices, mid_prices, def_prices, gk_prices are defined DataFrames
# Example:
fwd_prices = pd.DataFrame({'% Difference': [1, 2, 3]})
mid_prices = pd.DataFrame({'% Difference': [4, 5, 6]})
def_prices = pd.DataFrame({'% Difference': [7, 8, 9]})
gk_prices = pd.DataFrame({'% Difference': [10, 11, 12]})

# Create plots for each dataframe
plot(fwd_prices, 'forwards', 1)
plot(mid_prices, 'midfielders', 2)
plot(def_prices, 'defenders', 3)
plot(gk_prices, 'goalkeepers', 4)

plt.show()

print("""Summary stats for % Difference between value predicted using top 10 features
and FIFA 19 value:""")

for i,j in (fwd_prices,'Forwards'), (mid_prices,'Midfielders'), (
    def_prices,'Defenders'), (gk_prices,'Goalkeepers'):
    print("\n=========================================================================")
    print(j)
    print("=========================================================================")
    display(i['% Difference'].describe().to_frame())

data.columns

top_10_players = data.nlargest(10, 'Overall')

# Print the top 10 players
print(top_10_players[['Player', 'Overall']])

forwards = data[data['Position'].isin(['ST', 'CF', 'LW', 'RW', 'LF', 'RF'])]

# Filter midfielders (CM, CAM, CDM, etc.)
midfielders = data[data['Position'].isin(['CAM', 'CM', 'CDM', 'LM', 'RM', 'LAM', 'RAM'])]

# Filter defenders (CB, LB, RB, etc.)
defenders = data[data['Position'].isin(['CB', 'LB', 'RB', 'LCB', 'RCB', 'LWB', 'RWB'])]

# Get top 10 players for each category based on 'Overall' rating
top_10_forwards = forwards.nlargest(10, 'Overall')
top_10_midfielders = midfielders.nlargest(10, 'Overall')
top_10_defenders = defenders.nlargest(10, 'Overall')

# Print the top 10 players for each category
print("Top 10 Forwards:")
print(top_10_forwards[['Player', 'Overall']])

print("\nTop 10 Midfielders:")
print(top_10_midfielders[['Player', 'Overall']])

print("\nTop 10 Defenders:")
print(top_10_defenders[['Player', 'Overall']])